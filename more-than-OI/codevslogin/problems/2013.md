# 2013 good串   
### 时间限制： 2 s     空间限制： 256000 KB     题目等级： 大师  
## 题目描述：  

<pre>
1．对于给定的一个长度是N的0，1字符串S = s1s2...sn。
2．S的子串S(l,r) = [sl,sl+1,sl+2,...,sr]。
3．若S(l,r)中'0'的个数是'1'个数的2倍，称S(l,r)这个为good串，否则为bad串。
 
选择一对整数a, b (1 <= a <= b <= N)。
Num1：开始位置l和结束位置r都在闭区间[a,b]上的子串中good串的个数；
Num2：开始位置l和结束位置r都不在闭区间[a,b]上的子串中good串的个数，但可以包含[a,b]子串，即l，r有如下三种情况l<a且r<a，l>b且r>b，l<a且r>b；
求有多少对a, b使得Num1与Num2相等？
</pre>
  
  
## 输入描述：  

<pre>
第一行输入一个整数n。
第二行输入一个由’0’和’1’组成的长度为n的字符串。
</pre>
  
  
## 输出描述：  

<pre>
输出一个整数，即使Num1和Num2相等的a,b数对。
</pre>
  
  
## 样例输入：  

<pre><code>
3
010
</code></pre>
  
  
## 输出输出：  

<pre><code>
4
</code></pre>
  
  
## 数据范围及提示：  

<pre>
[a,b]=[1,1]时：
       开始位置l和结束位置r都在闭区间[a,b]上的子串如下：
       "0"(good子串的个数是0个)。
       开始位置l和结束位置r都不在闭区间[a,b]上的子串如下：
       "1","0","10"(good子串的个数是0个)。
所以[1,1]满足条件。
 
[a,b]=[1,2]时：
       开始位置l和结束位置r都在闭区间[a,b]上的子串如下：
       "0","1","01"(good子串的个数是0个)。
       开始位置l和结束位置r都不在闭区间[a,b]上的子串如下：
       "0"(good子串的个数是0个)。
所以[1,2]满足条件。
 
[a,b]=[1,3]时：
       开始位置l和结束位置r都在闭区间[a,b]上的子串如下：
       "0","1","0","01","10","010"(good子串的个数是1个:"010")。
       不存在开始位置l和结束位置r都不在闭区间[a,b]上的子串(good子串的个数是0个)。
所以[1,3]不满足条件。
 
[a,b]=[2,2]时：
       开始位置l和结束位置r都在闭区间[a,b]上的子串如下：
       "1"(good子串的个数是0个)。
       开始位置l和结束位置r都不在闭区间[a,b]上的子串如下：
       "0","0","010"(good子串的个数是1个:"010")。
所以[2,2]不满足条件。
 
[a,b]=[2,3]时：
       开始位置l和结束位置r都在闭区间[a,b]上的子串如下：
       "1","0","10"(good子串的个数是0个)。
       开始位置l和结束位置r都不在闭区间[a,b]上的子串如下：
       "0"(good子串的个数是0个)。
所以[2,3]满足条件。
 
[a,b]=[3,3]时：
       开始位置l和结束位置r都在闭区间[a,b]上的子串如下：
       "0"(good子串的个数是0个)。
       开始位置l和结束位置r都不在闭区间[a,b]上的子串如下：
       "0","1","01"(good子串的个数是0个)。
所以[3,3]满足条件。
 
所以有4对a,b满足题意。
 
10%的数据中1<=N<=60;
30%的数据中1<=N<=1000;
40%的数据中1<=N<=5000;
100%的数据中1<=N<=100000;
</pre>
  
  
***  

##### AC: 2  
##### WA: 2  
##### TLE: 0  
##### MLE: 0  
##### RE: 6  
